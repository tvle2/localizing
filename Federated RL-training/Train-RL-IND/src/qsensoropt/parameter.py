"""Submodule containing the class :obj:`Parameter` and the utility
function :func:`trim_single_param`.
"""

from typing import Tuple, Optional

from tensorflow import constant, ones, concat, expand_dims, \
    where, gather_nd, zeros, cast, linspace, print, Tensor
from tensorflow.math import greater, less, logical_and
from tensorflow.random import stateless_uniform


class Parameter:
    r"""This class provides the abstract description
    of a parameter that needs to be estimated in a
    quantum metrological task. The user can define one
    or more :py:obj:`Parameter` objects that represent
    the targets of the estimation.

    **Achtung!** The :py:obj:`Parameter` objects should only
    be defined within the initialization of a
    :py:obj:`~.PhysicalModel` object.

    In an experiment, the values of the parameters are encoded
    in the state of the quantum system used as a probe.
    Depending on whether we can directly access the encoding
    quantum channel or not, we classify the task as a
    **quantum estimation** problem, if we are only given
    the codified probe state, or as a **quantum metrology**
    problem, if we can access the channel.

    An example of parameter estimation would be receiving
    the radiation generated by a distribution of currents
    on a plane, which depends on the properties of the source,
    like the temperature for example [1]_. In this scenario,
    the quantum probe is the radiation. Since the emission
    of the radiation happens by hypothesis in a far and
    unaccessible region, we don't have direct access to
    the quantum channel that performs the encoding,
    but only to the encoded states :math:`\rho_T`,
    which is the state of the radiated field at detection.

    An example of a quantum metrological task is the
    estimation of the environmental magnetic field
    with a spin, for which we can choose the initial state
    and the duration of the interaction.
    The final state of the spin is :math:`\rho_B`.

    .. image:: ../docs/_static/ex_encoding.png
        :width: 400
        :alt: encoding

    A parameter can be continuous or discrete.
    Naturally continuous parameters are the magnetic
    field and the temperature, for example. A discrete
    parameter is the sign of a signal or the structure
    of an interaction [2]_. When discrete parameters
    are present, we are in the domain of **hypothesis testing**.
    In a metrological task, we may have a mix of continuous
    and discrete parameters, like in the
    :py:mod:`dolinar` receiver.

    A parameter can be a nuisance; which is an unknown
    parameter that needs to be estimated, on which we however do
    not evaluate the precision of the procedure because
    we are not directly interested in the estimation of
    this parameter. An example of this is the fluctuating
    optical visibility of an interferometer when we are
    only interested in the phase. Estimating the nuisance
    parameters is often necessary/useful to estimate the
    parameters of interest. Whether a parameter is a nuisance
    or not is not specified in the class :py:obj:`Parameter`,
    but in the user-defined method
    :py:meth:`~.StatefulSimulation.loss_function`
    of the classes
    :py:obj:`~.StatefulSimulation`.

    .. [1] E. Köse and D. Braun Phys. \
        Rev. A 107, 032607 (2023).
    .. [2] A. A. Gentile, B. Flynn, S. Knauer, \
        et al. Nat. Phys. 17, 837–843 (2021).

    Attributes
    ----------
    bounds: Tuple[float, float]
        Tuple of extrema of the set of admissible values
        for the parameter. It is defined both for continuous
        and discrete parameters. In this latter case it
        is `bounds[0]=min(values)` and `bounds[1]=max(values)`.
    values: Tuple[float, ...]
        Tuple of admissible values for a parameter.
        This tuple contains the values passed to the class
        constructor in the parameter `values`, sorted
        from the smallest to the largest and without
        repetitions.

        **Achtung!** This attribute is defined
        only for a discrete parameter.

    continuous: bool
        Determines if the parameter is continuous or not.
        It controls the behavior of the
        :py:meth:`reset` method.
    randomize: bool
        Determines if the initialization
        of the parameter values
        is stochastic or deterministic.
        It controls the behavior of
        the :py:meth:`reset` method.
    name: str
        Name of the parameter.
    bs: int
        Size of the first dimension of the
        `Tensor` produced by
        the :py:meth:`reset` method and number
        of estimations performed simultaneously
        in the simulation.
    prec: str
        Floating point precision of the parameter values,
        can be `float32` or `float64`.

    Notes
    -----
    Beside the variables passed to the constructor, a
    :py:obj:`Parameter` object requires the manual change of two
    other attributes to work properly. One attribute is
    the precision `prec`, which can be set to either `float32`
    or `float64` (with the default value being `float64`).
    The other attribute is the batchsize `bs`,
    which has a default value of 0. These changes are made
    automatically if the :py:obj:`Parameter` object is defined
    within the call to the constructor of the
    :py:obj:`~.PhysicalModel`
    class.
    """

    def __init__(self,
                 bounds: Optional[Tuple[float, float]] = None,
                 values: Optional[Tuple[float, ...]] = None,
                 randomize: bool = True, *,
                 name: str,
                 ):
        r"""
        Parameters passed to the class constructor.

        Parameters
        ----------
        bounds: Tuple[float, float], optional
            Tuple of floats containing the extrema of the interval
            of admissible values for a continuous parameter,
            where `bounds[0]` is the minimum and `bounds[1]`
            the maximum.

            .. image:: ../docs/_static/continuous_init.png
                :width: 400
                :alt: continuous_init

            If the `bounds` parameter is passed to the object
            constructor, then the :py:obj:`~.Parameter` object
            is automatically treated as
            continuous and the
            attribute `continuous` is therefore set to `True`.

            **Achtung!** The `bounds` and `values` parameters are
            mutually exclusive and cannot both be both passed to the
            :py:obj:`Parameter` class constructor.
        values: Tuple[float, ...], optional
            Tuple of float of unknown length containing the
            admissible values for a discrete parameter.
            Repetitions are ignored.

            .. image:: ../docs/_static/discrete_init.png
                :width: 400
                :alt: discrete_init

            If the `values` parameter is passed to the constructor of the
            object, this is automatically treated as a discrete parameter and the
            attribute `continuous` is set to `False`.

            **Achtung!** The `bounds` and `values` parameters are
            mutually exclusive and cannot both be both passed to the
            :py:obj:`Parameter` class constructor.

            **Achtung!** Even if only the `values` parameter is
            passed in the call to the class constructor, the `bounds`
            tuple is still included in the
            attributes. In this case it is defined as `bounds[0]=min(values)`
            and `bound[1]=max(values)`.
        randomize: bool = True
            This flag controls whether the function :py:meth:`reset` should
            generate random values or behave (almost) deterministically.

            **Note:** The value of this flag should be changed only
            for a discrete parameter.

            Th use of this flag is explained through the following example.
            Consider a parameter that can assume three values `{a, b, c}`. If the
            randomization is on and we call the :py:meth:`reset` method with
            parameter `num_particles`, we get a `Tensor` of shape (`bs`,
            `num_particles, 1)` where the entries of each row have been extracted
            uniformly and stochastically from the set `{a, b, c}`. For example,
            if `num_particles=12`, a row could look like
            `(a, b, a, c, b, b, a, c, a, c, a, b)`. If we however set `randomize=False`,
            then the rows are all equal to
            `(a, a, a, a, b, b, b, b, c, c, c, c)`. With the randomization
            turned off, if `k>1` is the number of admissible values for the
            parameter, we have `\lfloor num_particles/k \rfloor` repetitions of each element of
            the tuple `values` in each row of the output `Tensor`. If
            `num_particles` is not divisible by `k`, the values of the last, at
            most `k-1`, remaining particles are extracted uniformly and
            stochastically from the tuple `values`.

            If we generate a single particle, its value will always be extracted
            randomly and uniformly from `values`, since one will be
            always the remainder of the division `1/k`.

            The utility of setting `randomize=False` is confined to the task of
            hypothesis testing, where we want a number of particles in the
            particle filter that matches the number of hypotheses. In this case,
            in the initialization of the
            :py:obj:`~.ParticleFilter`
            object, we will set `num_particles=k`, with `k`
            being the number of hypotheses, so that with `randomize=False`, the
            particle filter ensemble contains exactly one and only one particle for each
            hypothesis. The :py:meth:`reset` method, called with
            parameter `num_particles=1` for generating the true values in the
            simulation, returns, however, a single uniformly randomly extracted
            hypothesis among the admissible ones defined in `values`.

            **Note:** Setting this flag to `False` for a continuous parameter has
            undesired effects. In this scenario the true values of the parameter
            in the simulation are generated by calling :py:meth:`reset` with
            `num_particles=1`, which, for a continuous parameter, is implemented
            as a `linspace(bounds[0], bounds[1], 1)`, that always returns
            `bounds[0]`.
        name: str
            Name of the parameter.

        """
        # We want only one of the two parameters to be
        # passed to the constructor, either the one defining
        # the values interval for a continuous parameter
        # or the list of values for the discrete parameter.
        if (bounds is not None) == (values is not None):
            raise ValueError("Only one between the optional \
                             parameters bounds and values \
                             is allowed to be passed.")

        if bounds is not None:
            self.bounds = bounds
            self.continuous = True
        if values is not None:
            self.values = tuple(sorted(set(values)))
            self.continuous = False
            # Also for a discrete parameter we define the
            # attribute `bounds`
            self.bounds = (min(self.values), max(self.values))

        self.randomize = randomize
        self.name = name

        # Placeholders for the definitions of these parameters
        # in the init function of the `ParticleFilter` object.
        self.bs = 0
        self.prec = "float64"

    def reset(
            self, seed: Tensor, num_particles: int,
            fragmentation: int = 1,
    ) -> Tensor:
        """Generates a `Tensor` of admissible values
        for the parameter.

        Produces a `Tensor` of shape (`bs`, `num_particles`, 1)
        of type `prec`, with a series of independent valid values
        for the parameter. Valid means that they lie in the
        interval specified by the tuple `bounds` if the parameter is
        continuous or, if it is discrete, that they belong to
        the tuple `values`, both being attributes of the
        :py:obj:`~.Parameter` class.
        The random entries are generated to cover
        uniformly the set of admissible values, whether it is discrete
        or continuous. According to the parameter `randomize`
        of the class constructor, this function implements a
        stochastic or deterministic generation of the
        `Tensor` entries.

        Parameters
        ----------
        seed: Tensor
            Seed of the random number generator that
            initializes the values of the parameter. It is a
            `Tensor` of type `int32` and of shape `(2,)`.

            This is the kind of seed that is accepted by the
            stateless random functions of the module
            :py:mod:`tensorflow.random`.
        num_particles: int
            Size of the second dimension of the `Tensor`
            generated by this method. It is the number of
            values generated for each batch.
        fragmentation: int = 1
            Number of pattern repetition
            in populating the particles with the parameter
            values. This parameter is only important for
            a discrete parameter with `randomize=False`.

        Returns
        -------
        Tensor
            `Tensor` of shape (`bs`, `num_particles`, 1)
            and type `prec`, where `bs` is the batch size of the
            :py:obj:`Parameter` object, `num_particles` is passed to
            the method call, and `prec` is the floating-point
            precision (can be either `float32` or `float64`),
            which is an attribute of the class :py:obj:`Parameter`.

        Notes
        -----
        This method is used in
        :py:obj:`~.ParticleFilter`
        to initialize the particle filter ensemble and in
        :py:obj:`~.PhysicalModel`
        and children classes to produce the true values of
        the parameter in the estimation task,
        according to which the outcomes of the measurements
        are simulated.

        **Achtung!**: This method should be called with `randomize=True`
        for a continuous parameter. If `randomize=False`, the true values of the
        parameter in the simulation of the estimation are generated
        by calling this method with `num_particles=1`, which,
        for a continuous parameter is
        implemented as a `linspace(bounds[0], bounds[1], 1)`, which
        always returns `bounds[0]`.
        """
        return self._reset_uniform(
            seed, num_particles,
            fragmentation=fragmentation,
        )

    def _reset_uniform(
            self, seed: Tensor, num_particles: int,
            fragmentation: int = 1,
    ) -> Tensor:
        if self.continuous:
            if self.randomize:
                return self._reset_uniform_continuous_random(
                    seed, num_particles,
                )
            return self._reset_uniform_continuous_deterministic(
                num_particles,
            )
        if self.randomize:
            return self._reset_uniform_discrete_random(
                seed, num_particles,
            )
        return self._reset_uniform_discrete_deterministic(
            seed, num_particles, fragmentation=fragmentation,
        )

    def _reset_uniform_continuous_deterministic(
            self, num_particles: int,
    ) -> Tensor:
        """Deterministic uniform prior for a
        continuous parameter.

        Returns a `Tensor` of shape (`bs`, `num_particles`, 1)
        with uniformly distributed particles in the range defined
        by `bounds`. The particles are generated through a
        `linspace` operation.

        Parameters
        ----------
        num_particles: int
            Size of the second dimension of the `Tensor`
            generated by this method. It is the number of
            values generated for each batch.
        fragmentation: int = 1
            Number of pattern repetition
            in populating the particles with the parameter
            values. This parameter is only important for
            a discrete parameter with `randomize=False`.

        Returns
        -------
        Tensor
            A `Tensor` of shape (`bs`, `num_particles`, 1)
            representing the generated particles.

        Notes
        -----
        The particles are deterministically generated through
        a `linspace` operation, as opposed to a stochastic
        process. This method is useful for creating a uniform
        prior distribution for the continuous parameter.
        """
        prior = linspace(
            self.bounds[0], self.bounds[1],
            num_particles,
            name="prior_deterministic_continuous")
        return prior

    def _reset_uniform_continuous_random(
            self, seed: Tensor, num_particles: int,
    ) -> Tensor:
        """Generates a stochastic uniform prior for a
        continuous parameter.

        Returns a `Tensor` of shape (`bs`, `num_particles`, 1) with
        uniformly distributed particles randomly extracted in the range
        defined by `bounds`.

        Parameters
        ----------
        seed: Tensor
            Seed of the random number generator that initializes the values
            of the parameter. It is a `Tensor` of type `int32` and of shape (`2`, ).
            This is the kind of seed that is accepted by the stateless random
            function of the module :py:mod:`tensorflow.random`.
        num_particles: int
            Size of the second dimension of the `Tensor` generated by this method.
            It is the number of values generated for each batch.

        Returns
        -------
        Tensor
            `Tensor` of shape (`bs`, `num_particles`, 1) and type `prec`,
            where `bs` is the batchsize of the :py:obj:`Parameter` object,
            `num_particles` is passed to the method call, and `prec` is the
            floating point precision (can either be `float32` or `float64`),
            which is also an attribute of the class :py:obj:`Parameter`.
        """
        random = stateless_uniform(
            (self.bs, num_particles, 1),
            seed, maxval=1, dtype=self.prec,
            name='random_uniform')
        prior = (self.bounds[1] - self.bounds[0])*random + \
            self.bounds[0]
        return prior

    def _reset_uniform_discrete_deterministic(
            self, seed: Tensor, num_particles: int,
            fragmentation: int = 1,
    ) -> Tensor:
        """Deterministic uniform prior for a discrete parameter

        Returns a `Tensor` of shape (`bs`, `num_particles`, 1) with
        `num_particles/k` particles in each batch element for each
        admissible value of the parameter, where `k` is the total number
        of admissible values, i.e `len(values)`.
        The remaining particles are assigned deterministically.

        Parameters
        ----------
        seed: Tensor
            Seed of the random number generator that initializes the values
            of the parameter. It is a `Tensor` of type `int32` and of shape (`2`, ).
            This is the kind of seed that is accepted by the stateless random
            function of the module :py:mod:`tensorflow.random`.
        num_particles: int
            The number of values to generate for each
            estimation in the batch.
        fragmentation: int = 1
            Number of pattern repetition
            in populating the particles with the parameter
            values. This parameter is only important for
            a discrete parameter with `randomize=False`.

        Returns
        -------
        Tensor
            A `Tensor` of shape (`bs`, `num_particles`, 1)
            containing the values of the parameter.
        """
        num_values = len(self.values)
        # Virtual num_particles
        virt_particles, _ = divmod(num_particles, fragmentation)
        pp_value, _ = divmod(virt_particles, num_values)
        prior = zeros((self.bs, 0, 1), dtype=self.prec)
        ones_tensor = ones(
            (self.bs, pp_value, 1), dtype=self.prec,
        )
        for _ in range(fragmentation):
            # Particles per value and remainder
            for value in self.values:
                prior = concat(
                    [prior, cast(
                        value*ones_tensor, dtype=self.prec,
                    )], 1,
                )
        remainder_prior = self._reset_uniform_discrete_random(
            seed,
            num_particles-len(self.values)*pp_value*fragmentation,
        )
        return concat(
            [prior, remainder_prior], 1,
            name="prior_deterministic_discrete",
        )

    def _reset_uniform_discrete_random(
            self, seed: Tensor, num_particles: int,
    ) -> Tensor:
        """Stochastic uniform prior for a discrete parameter.

        Returns a `Tensor` of shape (`bs`, `num_particles`, 1)
        with uniformly distributed particles randomly extracted
        among the elements of the attribute `values`.

        Parameters
        ----------
        seed: Tensor
            Seed of the random number generator
            that initializes the values
            of the parameter. It is a
            `Tensor` of type `int32` and of shape (`2`, ).
            This is the kind of seed that is accepted
            by the stateless random
            function of the module :py:mod:`tensorflow.random`.
        num_particles: int
            The number of values to generate for each
            estimation in the batch.

        Returns
        -------
        Tensor
            A `Tensor` of shape (`bs`, `num_particles`, 1)
            containing the values of the parameter.
        """
        num_values = len(self.values)
        # Create a Tensor of shape (bs, num_particles, 1)
        indices = stateless_uniform(
            (self.bs, num_particles, 1), seed,
            minval=0, maxval=num_values,
            dtype="int32",
        )
        # Use the generated Tensor as an index
        # into the set of values
        return expand_dims(gather_nd(
            constant(self.values, dtype=self.prec),
            indices,
        ), axis=2, name="prior_discrete_random",)


def trim_single_param(
        old_param: Tensor, param: Parameter,
        one_arr: Tensor,
) -> Tensor:
    """Trims the values of a given `Tensor` to be within the
    bounds set for the corresponding :py:obj:`~.Parameter` object.
    If the parameter is discrete the values of the
    particles are levelled to the closest element
    among the admissible values.

    Parameters
    ----------
    old_param: Tensor
        `Tensor` of values for the parameter `param` that do not necessarily
        lay in the acceptable region of parameter values, defined by `param.bounds`.
        The shape and the type of this `Tensor` must be the same of `one_arr`.
    param: Parameter
        Describes abstractly the parameter.
    one_arr: Tensor
        `Tensor` filled with ones, of the same type and shape as `old_param`.

    Returns
    -------
    Tensor
        A modified version of `old_param`, where all the entries that were
        greater than `param.bounds[1]` have been set to `param.bounds[1]`
        and all those that were smaller than `param.bounds[0]` have been set
        to `param.bounds[0]`. If the parameter is discrete and some entries of
        `old_param` don't exactly belong to the set of admissible values,
        i.e. `param.values`, the said entries are "levelled" to the closest
        element of `param.values`. This is useful
        for correcting the distortions of the discrete parameter values
        introduced by the perturbation in the resampling procedure.

    Notes
    -----
    Since discrete parameters also have a `bounds` attribute, this function
    works on them as well. It is used in the resampling routine of
    the :py:obj:`~.ParticleFilter` class,
    where the particles are perturbed or newly generated and could
    fall out of the admissible values set.
    """
    bounds = param.bounds
    # Cap lower
    new_param = where(
        less(old_param, bounds[0]*one_arr),
        bounds[0]*one_arr,
        old_param,
        name='cap_lower'
    )
    # Cap upper
    new_param = where(
        greater(old_param, bounds[1]*one_arr),
        bounds[1]*one_arr,
        new_param,
        name='cap_upper'
    )
    # If the parameter is discrete
    # the perturbations should be
    # levelled
    if not param.continuous:
        mean_values = [sum(x)/2 for x in
                       zip(param.values[1:], param.values[:-1])]
        # Level lower
        new_param = where(
            less(old_param, mean_values[0]*one_arr),
            param.values[0]*one_arr,
            old_param,
            name='level_lower'
        )
        # Level upper
        new_param = where(
            greater(old_param, mean_values[-1]*one_arr),
            param.values[-1]*one_arr,
            new_param,
            name='level_upper'
        )
        for i in range(1, len(mean_values)):
            new_param = where(
                logical_and(
                    less(old_param, mean_values[i]*one_arr),
                    greater(old_param, mean_values[i-1]*one_arr),
                ),
                param.values[i]*one_arr,
                new_param,
                name='level_values'
            )
    return expand_dims(
        new_param, axis=2, name='trim_param',
    )
